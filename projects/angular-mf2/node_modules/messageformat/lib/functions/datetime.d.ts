import type { MessageExpressionPart } from '../formatted-parts.ts';
import type { MessageValue } from '../message-value.ts';
import type { MessageFunctionContext } from '../resolve/function-context.ts';
/**
 * The resolved value of a {@link DraftFunctions.date | :date},
 * {@link DraftFunctions.datetime | :datetime}, or {@link DraftFunctions.time | :time} expression.
 *
 * @beta
 */
export interface MessageDateTime extends MessageValue<'datetime'> {
    readonly type: 'datetime';
    readonly dir: 'ltr' | 'rtl' | 'auto';
    readonly options: Readonly<Intl.DateTimeFormatOptions>;
    toParts(): [MessageDateTimePart];
    toString(): string;
    valueOf(): Date;
}
/**
 * The formatted part for a {@link MessageDateTime} value.
 *
 * @beta
 * @category Formatted Parts
 */
export interface MessageDateTimePart extends MessageExpressionPart<'datetime'> {
    type: 'datetime';
    locale: string;
    parts: Intl.DateTimeFormatPart[];
}
/**
 * The function `:datetime` is used to format a date/time value.
 * Its formatted result will always include both the date and the time, and optionally a timezone.
 *
 * @beta
 */
export declare const datetime: (ctx: MessageFunctionContext, options: Record<string, unknown>, operand?: unknown) => MessageDateTime;
/**
 * The function `:date` is used to format the date portion of date/time values.
 *
 * @beta
 */
export declare const date: (ctx: MessageFunctionContext, options: Record<string, unknown>, operand?: unknown) => MessageDateTime;
/**
 * The function `:time` is used to format the time portion of date/time values.
 * Its formatted result will always include the time, and optionally a timezone.
 *
 * @beta
 */
export declare const time: (ctx: MessageFunctionContext, options: Record<string, unknown>, operand?: unknown) => MessageDateTime;
